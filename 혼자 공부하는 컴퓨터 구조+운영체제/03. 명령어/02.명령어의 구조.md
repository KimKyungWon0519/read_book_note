# 02. 명령어의 구조

## 연산 코드와 오퍼랜드

### 명령어

연산 코드와 오퍼랜드로 구성

### 연산 코드 (=연산자)

명렁어가 수행할 연산

**연산 코드의 가장 기본적인 연산 유형**

- 데이터 전송
    - `MOVE` : 데이터를 옮김
    - `STORE` : 메모리에 저장
    - `LOAD` : 메모리에서 CPU로 데이터를 가져옴
    - `PUSH` : 스택에 데이터를 저장함
    - `POP` : 스택의 최상단 데이터를 가져옴
- 산술/논리 연산
    - `ADD` , `SUBTRACT` , `MULTIPLY`, `DIVIDE`: 덧셈, 뺄셈, 곱셈, 나눗셈을 수행
    - `INCREMENT`, `DECREMENT`: 오퍼랜드에 1을 더함, 오퍼랜드에 1을 뺌
    - `AND`, `OR`, `NOT`: AND, OR, NOT 연산을 주행
    - `COMPARE`: 두 개의 숫자 또는 TRUE, FALSE 값을 비교
- 제어 흐름 변경
    - `JUMP`: 특정 주소로 실행 순서를 옮김
    - `CONDITIONAL JUMP`: 조건에 부합할 때 특정 주소로 실행 순서를 옮김
    - `HALT`: 프로그램 실행을 TEST IO멈춤
    - `CALL`: 되돌아올 주소를 저장한 채 특정 주소로 실행 순서를 옮김
    - `RETURN`: CALL을 호출 할 때 저장했던 주소로 돌아감
- 입출력 제어
    - `READ`: 특정 입출력 장치로 부터 데이터를 읽음
    - `WRITE`: 특정 입출력 장치로 데이터를 씀
    - `START TO`: 입출력 장치를 시작
    - `TEST IO`: 입출력 장치의 상태를 확인

### 오퍼랜드 (=피연산자)

연산에 사용할 데이터가 저장된 위치

오퍼랜드 필드에는 숫자와 문자 등을 나타내느 데이터 또는 메모리나 레지스터 주소가 올 수 있음 

다만 오퍼랜드 필드에 데이터를 직접 명시하기 보다, 메모리 주소나 레지스터 주소를 담음 (이러한 점 때문에 오퍼랜드 필드를 **주소 필드**라고 함)

오퍼랜드는 명령어 안에 하나도 없을 수도 있고, 여러개가 있을 수도 있다.

예시)

```nasm
mov eax, 0  // 오퍼랜드가 두 개인 경우
pop rpb     // 오퍼랜드가 한 개인 경우
ret         // 오퍼랜드가 없는 경우
```

- 0-주소 명령어: 오퍼랜드가 하나도 없는 명령어
- 1-주소 명령어: 오퍼랜드가 하나인 명령어
- 2-주소 명령어: 오퍼랜드가 두 개인 명령어
- 3-주소 명령어: 오퍼랜드가 세 개인 명령어

**연산 코드와 오퍼랜드**

`push`, `ret` : 연산 코드

`rpb` : 오퍼랜드

```nasm
push rbp
ret
```

---

## 주소 지정 방식

**오퍼랜드 필드에 메모리나 레지스터 주소를 담는 이유**

명령어 길이가 제한적이다.

하나의 명령어가 n비트 및 연산 코드 필드가 m비트로 구성

오퍼랜드 필드의 길이는 연산 코드만큼의 길이를 뺀 n-m 비트가 됨. 따라서 오퍼랜드의 개수가 많을 수록 오퍼랜드 필드의 크기는 작아진다.

예시)

명령어 크기가 16비트라고 가정

연산 코드 필드가 4비트

- 2-주소 명령어 오퍼랜드
    - 16-4=12 ⇒ 12/2 ⇒ 6
    - 오퍼랜드 필드당 6비트 사용 가능
- 3-주소 명령어 오퍼랜드
    - 16-4=12 ⇒ 12/3 ⇒ 4
    - 오퍼랜드 필드당 4비트 사용 가능

**오퍼랜드 필드에 메모리 주소나 레지스터 이름으로 명시할 경우**

- 메모리 주소를 명시할 경우
    - 저장할 수 있는 메모리 크기 만큼 사용 가능
    - 16비트를 저장할 수 있는 메모리라면 16비트 만큼 사용 가능
- 레지스터 이름으로 명시할 경우
    - 레지스터가 저장할 수 있는 공간 만큼 사용 가능

### 유효 주소

연산의 대상이 되는 데이터가 저장되는 위치 (메모리 주소나 레지스터 이름)

### 주소 지정 방식

연산에 사용할 데이터 위치를 찾는 방법

주소 지정 방식의 종류

- **즉시 주소 지정 방식 ( immediate addressing mode )**
    - 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시하는 방식
    - 데이터 크기가 작아지는 단점이 존재
    - 주소 지정 방식 중에 가장 빠른 주소 지정 방식
- **직접 주소 지정 방식 ( direct addressing mode )**
    - 오퍼랜드 필드에 유효 주소를 직접적으로 명시하는 방식
    - 오퍼랜드 필드에서 표현할 수 있는 데이터 크기는 즉시 주소 지정 방식보단 크다
    - 오퍼랜드 필드의 길이가 연산 코드의 길이 만큼 짧아져 표현할 수 있는 유효 주소에 제한이 생길 수 있는 단점이 존재
- **간접 주소 지정 방식 ( indirect addressing mode )**
    - 유효 주소의 주소를 오퍼랜드 필드에 명시
        - 완벽하진 않지만 오퍼랜드 필드의 제한을 간접적으로 우회
    - 동적 데이터 참조가 가능하다.
        - 유효주소의 주소에 접근하여 유효주소를 유연하게 변경 가능
    - 두 번의 메모리 접근을 하기 때문에 다른 주소 지정 방식 보다 느린 방식
- **레지스터 주소 지정 방식 ( Register Addressing mode )**
    - 직접 주소 지정 방식과 비슷하게 레지스터를 오퍼랜드 필드에 직접 명시
    - 직접 주소 지정 방식보다 빠르게 데이터를 접근 가능
        - CPU 외부에 있는 메모리에 접근 하는 것 보다 CPU 내부에 있는 레지스터에 접근하는 것이 빠르기 떄문
    - 직접 주소 지정 방식과 동일한 문제를 공유
        - 표현할 수 있는 레지스터 크기에 제한이 생길 수 있음
- **레지스터 간접 주소 지정 방식 ( Register indirect addressing mode )**
    - 연산에 사용할 데이터는 메모리에 저장하고, 해당 유효 주소를 저장한 레지스터를 오퍼랜드 필드에 명시 하는 방법
    - 유효 주소를 찾는 과정은 간접 주소 방식과 비슷하지만, 메모리에 접근 하는 횟수는 한 번으로 줄어듦
    - 간접 주소 지정 방식보다 빠르다.